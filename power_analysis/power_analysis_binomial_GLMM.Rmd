---
title: "power analysis - binomial GLMM"
author: "Christoph VÃ¶lter"
date: "31/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

load("power_sim_disjunctive_syll.RData")
```

## Generate data

```{r}

set.seed(1)
n.subject <- 16 # number subjects
n.per.subject <- 18 # observations per subject
n.per.condition <- 18 # observations per subject and condition
subj.id <- as.factor(paste("subj", 1:n.subject, sep = "."))
age_range <- c(8:40) # age range between 8 and 40
control.per <- 1/3 # performance in control condition
test.per <- 0.55 # performance in test condition

start.data <- data.frame(subj.id)
# duplicate rows according to the number obs. per subject:
start.data <- start.data[rep(x = 1:nrow(start.data), times = n.per.subject), ]
start.data <- as.data.frame(start.data)
names(start.data) <- "subj.id"

# add condition and trial number
start.data <- data.frame(expand.grid(subj.id = subj.id, condition = c("control", "test"), trial = c(1:n.per.condition)))

# add age
age <- sample(x = age_range, size = length(unique(start.data$subj.id)), replace = T)
start.data$age <- as.numeric(age[as.numeric(start.data$subj.id)])

# add sex
sex <- sample(x = c("F", "M"), size = length(unique(start.data$subj.id)), replace = T)
start.data$sex <- as.factor(sex[as.numeric(start.data$subj.id)])

## add order
start.data$order <- rep(x = c("test_first", "control_first"), times = nrow(start.data) / 2)

start.data <- start.data %>%
  mutate(order2 = as.numeric(ifelse(order == "test_first" & condition == "test", "1", ifelse(order == "test_first" & condition == "control", "2", ifelse(order == "control_first" & condition == "control", "1", ifelse(order == "control_first" & condition == "test", "2", ""))))))

#z-transformation of covariates
start.data$z.age=as.vector(scale(start.data$age))
start.data$z.trial=as.vector(scale(start.data$trial))
start.data$z.order=as.vector(scale(as.numeric(start.data$order2)))

#dummy code factors
start.data$condition.dummy=as.numeric(start.data$condition==levels(start.data$condition)[2])

#center condition for random slopes:
start.data$condition.c=as.numeric(start.data$condition)-mean(as.numeric(start.data$condition))


# checks:
# does each subject have only one sex and age?
xx <- table(start.data$subj.id, start.data$sex)
range(apply(X = xx > 0, MARGIN = 1, sum)) # should be 1 and 1

xx <- table(start.data$subj.id, start.data$age)
range(apply(X = xx > 0, MARGIN = 1, sum)) # should be 1 and 1

xx <- table(start.data$subj.id, start.data$condition)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$subj.id, start.data$trial)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$condition, start.data$order)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$subj.id, start.data$order)
range(apply(X = xx > 0, MARGIN = 1, sum))
```


## parameterization of the fixed effects
```{r}
pv <- c(0, 1)
c0 <- log(control.per / (1 - control.per)) # intercept
c.test <- log(test.per / (1 - test.per)) - log(control.per / (1 - control.per)) / (max(pv) - min(pv)) # slope
#c.test <- (qlogis(test.per) - qlogis(control.per)) / (max(pv) - min(pv)) # slope using qlogis

LP <- c0 + c.test * pv # linear predictor
rv <- exp(LP) / (1 + exp(LP)) # response variable
range(rv)
```

```{r}
par(mar=c(3, 3, 0.2, 0.2), mgp=c(1.7, 0.3, 0), tcl=-0.2, las=1)
plot(x=pv, y=rv, type="hist", ylim=c(0, 1),
xlab="condition", ylab="correct choice")
```



### parameterising the response

```{r}
n.simus <- 10 # small number for testing
r.effects <- c(0.175, 0.35, 0.7) # random effects to be simulated
# with the intercept being -0.6931472 (qlogis(1/3)) we could make the following
# guesses for the random intercept:
#- 0.175: tiny random intercepts effect
#- 0.35: moderate random intercepts effect
#- 0.7: strong random intercepts effect
#- 1.4: very strong random intercepts effect

r.slope.con <- c(0.45, 0.9)
# with the intercept being -0.8938179 (qlogis(1/3)-qlogis(0.55)) we could make the following
# guesses for the random intercept:
#- 0.225: tiny random intercepts effect
#- 0.45: moderate random intercepts effect
#- 0.9: strong random intercepts effect
#- 1.8: very strong random intercepts effect

r.slope.trial <- 0.1
r.slope.order <- 0.1

# create object to store the simulation parameters and results:
all.res <- data.frame(expand.grid(
  n.per.subject = n.per.subject, r.effect = r.effects, 
  r.slope.con = r.slope.con, r.slope.trial = r.slope.trial, r.slope.order = r.slope.order,
  simu = 1:n.simus
))
all.res$icpt <- NA
all.res$conditiontest <- NA
all.res$re.sd <- NA
all.res$warns.full <- NA
all.res$warns.null <- NA
all.res$lrt.p.con <- NA
all.res$full.null.p <- NA

all.ests=matrix(NA, nrow=n.simus, ncol=1)
colnames(all.ests)=c("lrt.p.con")

# create data frame with design:
## done above

# load packages needed:
library(lme4)
# Loading required package: Matrix
library(kyotil) # we want to store info about convergence issues

# define control structure to make convergence more likely:
contr <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 10000))

xdata <- start.data

coefs <- c(
  "(Intercept)" = log(control.per / (1 - control.per)),
  "conditiontest" = log(test.per / (1 - test.per)) - log(control.per / (1 - control.per)),
  "z.age" = 0,
  "sexM" = 0,
  "z.trial" = 0,
  "z.order" = 0
)

m.mat <- model.matrix(object = ~condition + z.age + sex + z.trial + z.order, data = xdata) # create model martix

# run simulation
for (i in 1:nrow(all.res)) {
  set.seed(i) # allows to later replicate individual simulations

  # xdata <- start.data[rep(x = 1:nrow(start.data), each = all.res[i, "n.per.subject"]), ]  # replicate rows in start.data according to sample size

  LP <- m.mat[, names(coefs)] %*% coefs # LP wrt fixed effects
  
  # add random effect to linear predictor:
  LP <- LP + rnorm(n = n.subject, sd = all.res[i, "r.effect"])[as.numeric(xdata$subj.id)] + 
    rnorm(n = n.subject, sd = all.res[i, "r.slope.con"])[as.numeric(xdata$subj.id)]*xdata$condition.dummy +
    rnorm(n = n.subject, sd = all.res[i, "r.slope.trial"])[as.numeric(xdata$subj.id)]*xdata$z.trial +
    rnorm(n = n.subject, sd = all.res[i, "r.slope.order"])[as.numeric(xdata$subj.id)]*xdata$z.order 

  # generate response:
  xdata$correct <- rbinom(n = nrow(xdata), size = 1, prob = exp(LP) / (1 + exp(LP)))

  # fit full model:
  full <- keepWarnings(glmer(correct ~ condition + z.age + sex + z.trial + z.order + (1 + condition.c + z.trial + z.order || subj.id),
    data = xdata, family = binomial, control = contr
  ))
  # fit null model:
    null <- keepWarnings(glmer(correct ~ z.trial + z.order + (1 + condition.c + z.trial + z.order || subj.id),
    data = xdata, family = binomial, control = contr
  ))
    
  # store results:
  all.res[i, c("icpt", "conditiontest", "z.age", "sexM", "z.trial", "z.order")] <- fixef(full$value)
  all.res[i, "re.sd"] <- as.data.frame(summary(full$value)$varcor)[1, "sdcor"]
  all.res[i, "warns.full"] <- nchar(paste(full$warnings, collapse = ""))
  all.res[i, "warns.null"] <- nchar(paste(null$warnings, collapse = ""))
  all.res[i, "lrt.p.con"] <- as.data.frame(drop1(full$value, test="Chisq"))["condition", "Pr(Chi)"]
  all.res[i, "full.null.p"] <- as.data.frame(anova(null$value, full$value, test="Chisq"))[2, "Pr(>Chisq)"]
}



```

## evaluation of results 

* number of warning per combinations of random effects
```{r}
#full model
tapply(X=all.res[, "warns.full"]>0, INDEX=all.res[, c("r.slope.con", "r.effect")],
FUN=sum)

#null model: 
tapply(X=all.res[, "warns.null"]>0, INDEX=all.res[, c("r.slope.con", "r.effect")],
FUN=sum)
```

* plotting the estimates

```{r}
par(mar=c(3, 3, 0.2, 0.2), mgp=c(1.7, 0.3, 0), tcl=-0.15, las=1)
plot(
  x = as.numeric(as.factor(rep(
    x = c("icpt", "conditiontest", "re.sd"),
    each = nrow(all.res)
  ))),
  y = unlist(all.res[, c("icpt", "conditiontest", "re.sd")]),
  pch = 19, col = grey(level = 0.2, alpha = 0.2),
  xaxt = "n", xlim = c(0.5, 3.5), ylab = "estimate", xlab = ""
)
mtext(text = c("icpt", "conditiontest", "re.sd"), side = 1, at = 1:3, line = 0.2)
```

* models that converged without warnings:
```{r}
all.res2=subset(all.res, warns.full==0)

table(round(all.res2$conditiontest))

```

### How many LRTs of condition are significant?
```{r}
lrt.data <- all.res %>%
  group_by(r.effect, r.slope.con) %>%
  summarise(lrt.p.con.mean = mean(lrt.p.con), 
            n.sign.lrt = length(lrt.p.con[lrt.p.con <= 0.05]), 
            n.lrt = length(lrt.p.con), 
            proportion.sign.lrt = length(lrt.p.con[lrt.p.con <= 0.05]) / length(lrt.p.con),
            full.null.p.mean = mean(full.null.p), 
            n.sign.full.null.p = length(full.null.p[full.null.p <= 0.05]),
            n.fn = length(full.null.p), 
            proportion.sign.fn = length(full.null.p[full.null.p <= 0.05]) / length(full.null.p),)

lrt.data
```

#### Plotting the proportion of significant Full-null model comparisons

```{r}

ggplot(data = lrt.data, aes(y=proportion.sign.fn))+
  geom_point(aes(x=as.factor(r.effect), y=proportion.sign.fn))+
  geom_boxplot(aes(x=as.factor(r.effect), y=proportion.sign.fn, group=r.effect))+
  #theme_classic()+
  geom_hline(yintercept=0.8, colour="red", lty=2)+
  facet_wrap(~r.slope.con)

```



#### Plotting the proportion of significant LRTs for the predictor variable condition

```{r}

ggplot(data = lrt.data, aes(y=proportion.sign.lrt))+
  geom_point(aes(x=as.factor(r.effect), y=proportion.sign.lrt))+
  geom_boxplot(aes(x=as.factor(r.effect), y=proportion.sign.lrt, group=r.effect))+
  #theme_classic()+
  geom_hline(yintercept=0.8, colour="red", lty=2)+
  facet_wrap(~r.slope.con)

```





#### Plotting the intercepts
```{r}
#some preparation for plotting:
par(mar=c(3, 3, 0.2, 0.2), mgp=c(1.7, 0.3, 0), tcl=-0.15, las=1)
where=as.numeric(as.factor(paste(all.res2$r.effect, all.res2$r.slope.con,
sep="_")))

plot(x=where, y=all.res2$icpt, xlab="", xaxt="n", pch=19,
col=grey(level=0.5, alpha=0.5), cex=1.5)
abline(h=coefs["(Intercept)"])
mtext(text=rep(x=r.slope.con, times=length(r.effects)), side=1, line=0.2,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="r.slope", side=1, line=0.2, at=0.5, cex=1)
mtext(text=rep(x=r.effects, each=length(r.slope.con)), side=1, line=1.4,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="re:", side=1, line=1.4, at=0.5, cex=1)
abline(v=(1:length(r.effects))[-length(r.effects)]*length(r.slope.con)+0.5,
lty=2)
```

#### Plotting the fixed effect of condition
```{r}

plot(x=where, y=all.res2$conditiontest, xlab="", xaxt="n", pch=19,
col=grey(level=0.5, alpha=0.5), cex=1.5)
abline(h=coefs["conditiontest"])
mtext(text=rep(x=r.slope.con, times=length(r.effects)), side=1, line=0.2,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="r.slope", side=1, line=0.2, at=0.5, cex=1)
mtext(text=rep(x=r.effects, each=length(r.slope.con)), side=1, line=1.4,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="re:", side=1, line=1.4, at=0.5, cex=1)
abline(v=(1:length(r.effects))[-length(r.effects)]*length(r.slope.con)+0.5,
lty=2)
```
#### Plotting the random intercept
```{r}
plot(x=where, y=all.res2$re.sd, xlab="", xaxt="n", pch=19,
col=grey(level=0.5, alpha=0.5), cex=1.5)
hll=1.0
where2=((1:length(r.effects))-1)*length(r.slope.con)+1.5
segments(x0=where2-hll, x1=where2+hll, y0=r.effects, y1=r.effects)
mtext(text=rep(x=r.slope.con, times=length(r.effects)), side=1, line=0.2,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="r.slope", side=1, line=0.2, at=0.5, cex=1)
mtext(text=rep(x=r.effects, each=length(r.slope.con)), side=1, line=1.4,
at=1:(length(r.effects)*length(r.slope.con)), cex=1)
mtext(text="re:", side=1, line=1.4, at=0.5, cex=1)
abline(v=(1:length(r.effects))[-length(r.effects)]*length(r.slope.con)+0.5,
lty=2)
```


#### Plotting the full-null model comparison p-values
```{r}
ggplot(data = all.res, aes(y=full.null.p))+
  geom_point(aes(x=as.factor(r.effect), y=full.null.p))+
  geom_boxplot(aes(x=as.factor(r.effect), y=full.null.p, group=r.effect))+
  #theme_classic()+
  scale_y_continuous(trans='log10')+
  geom_hline(yintercept=0.05, colour="red", lty=2)+
  facet_wrap(~r.slope.con)

```

#### Plotting the LRT p-values of condition
```{r}
ggplot(data = all.res, aes(y=lrt.p.con))+
  geom_point(aes(x=as.factor(r.effect), y=lrt.p.con))+
  geom_boxplot(aes(x=as.factor(r.effect), y=lrt.p.con, group=r.effect))+
  #theme_classic()+
  scale_y_continuous(trans='log10')+
  geom_hline(yintercept=0.05, colour="red", lty=2)+
  facet_wrap(~r.slope.con)

```




```{r}
save.image("power_sim_disjunctive_syll.RData")
```



